<?php

/**
 * @file
 * Integrates the lite track changes plugin for CKEditor with Drupal.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\ContentEntityForm;
use Drupal\Core\Routing\RouteMatchInterface;

/**
 * Implements hook_help().
 */
function lite_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.lite':
      $url = Drupal::urlGenerator();
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Lite integrates the <a href=":url">LITE track changes</a> plugin for CKEditor with Drupal.', [':url' => 'https://ckeditor.com/addon/lite']);
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<p>';
      $output .= t('You should create a specific text format and probably a content type and roles for easiest configuration of Lite.');
      $output .= '<br>' . t('Module <a href=":url">allowed formats</a> can help you force tracking on a content type.', [':url' => 'https://www.drupal.org/project/allowed_formats']);
      $output .= '</p>';
      $output .= '<h4>' . t('Basic usage') . '</h4>';
      $output .= '<p>';
      $output .= t('From the text format settings you can enable <em>tracking by default</em> on Lite options. If the role do not have the permission provided by this module to toggle tracking, it will be forced.');
      $output .= '<br>' . t('This module permissions can restrict accept / reject changes to specific roles.') . '</p>';
      $output .= '<h4>' . t('Advanced settings') . '</h4>';
      $output .= '<p>' . t('You can enable <a href=":url">extra permissions</a> by text formats to get a more fine grain permissions. Note that main permissions always override permissions by formats.', [':url' => $url->generate('lite.lite_settings_form')]) . '</p>';
      $output .= '<h4>' . t('Content moderation support') . '</h4>';
      $output .= '<p>';
      $output .= t('If the Drupal <a href=":url">Content Moderation</a> module is enabled, Lite text format option by Workflow and by states will be available.', [':url' => 'https://www.drupal.org/docs/8/core/modules/content-moderation']);
      $output .= '<br>' . t('Prior to text format configuration you must enable a Workflow on your content type and set the Workflow transitions permissions to your roles accordingly.');
      $output .= '</p>';
      $output .= '<p>';
      $output .= t('The Lite text format settings will allow a fine grain configuration of the <em>Auto tracking</em> by Workflow and by States.');
      $output .= '<br>' . t('You must ensure related roles got permission to access enabled content moderation states.');
      $output .= '</p>';
      $output .= '<p>' . t('With Content Moderation module enable, you can enable <a href=":url">extra permissions</a> by states to get a more fine grain permissions.', [':url' => $url->generate('lite.lite_settings_form')]) . '</p>';
      $output .= '<h5>' . t('Content moderation issues') . '</h5>';
      $output .= '<p>';
      $output .= t('If a role is not granted toggle or resolve permissions for a moderation state but has permission to move to the next transition, nothing will prevent the user for saving. You should check carrefully you settings and permissions.');
      $output .= t('A debug option on Lite settings can help you check your configuration.');
      $output .= '</p>';
      return $output;

    break;

  }
}

/**
 * Implements hook_libraries_info().
 */
function lite_libraries_info() {
  return [
    'lite' => [
      'name' => 'LITE',
      'vendor url' => 'http://www.loopindex.com/portfolio-item/track-changes-plugin/',
      'download url' => 'http://ckeditor.com/addon/lite',
      'version arguments' => [
        'file' => 'plugin.js',
        // /* Source version: 1.2.28 */.
        'pattern' => '/Source version: (\d+\.\d+\.\d+)/',
        'lines' => 1,
      ],
      'files' => [
        'js' => [
          'lite-includes.js',
          'lite-interface.js',
          'plugin.js',
        ],
      ],
    ],
  ];
}

/**
 * Implements hook_element_info_alter().
 *
 * @see \Drupal\filter\Element\TextFormat
 */
function lite_element_info_alter(array &$types) {
  // Our process callback must run immediately after
  // TextFormat::processFormat().
  if (isset($types['text_format']) && isset($types['text_format']['#process'])) {
    $search_value = ['Drupal\filter\Element\TextFormat', 'processFormat'];
    $key = array_search($search_value, $types['text_format']['#process']);
    if ($key !== FALSE) {
      $key++;
      array_splice($types['text_format']['#process'], $key, 0, 'lite_filter_process_format');
    }
    else {
      $types['text_format']['#process'][] = 'lite_filter_process_format';
    }
  }
}

/**
 * Process callback for form elements that have a text format selector attached.
 *
 * This callback runs after filter_process_format() and performs additional
 * modifications to the form element.
 *
 * @see \Drupal\filter\Element\TextFormat::processFormat()
 */
function lite_filter_process_format(&$element, FormStateInterface $form_state, &$complete_form) {
  // Retrieve the form object from $form_state.
  $form_object = $form_state->getFormObject();

  // Check to see if we're working with a content entity form.
  if ($form_object instanceof ContentEntityForm) {

    // Retrieve the entity related to the form.
    if (!$entity = $form_state->getFormObject()->getEntity()) {
      return $element;
    }

    $is_new = $entity->isNew();
    // And pass it to the element as custom settings.
    $element['#lite_node_values'] = [
      'bundle' => $entity->bundle(),
      'new' => $is_new,
      'moderated' => FALSE,
      'workflow' => FALSE,
      'state' => NULL,
    ];

    // Ensure service can be loaded to avoid install errors.
    if (\Drupal::moduleHandler()->moduleExists('content_moderation') && \Drupal::hasService('content_moderation.moderation_information')) {
      /** @var \Drupal\content_moderation\ModerationInformationInterface $moderation_info */
      $moderation_info = \Drupal::service('content_moderation.moderation_information');

      // Add our values to help us for processing config and state.
      $element['#lite_node_values']['moderated'] = $moderation_info->isModeratedEntity($entity);
      if ($workflow = $moderation_info->getWorkflowForEntity($entity)) {
        $element['#lite_node_values']['workflow'] = $workflow->id();
      }
      if (!$is_new) {
        $element['#lite_node_values']['state'] = $entity->moderation_state->value;
      }
    }
    // We can add our pre_render callback to disable tracking depending options.
    $element['#pre_render'][] = 'lite_disable_tracking';
  }

  return $element;
}

/**
 * Pre-render function to disable text tracking depending text format settings.
 *
 * We use Lite configuration to start or disable tracking, see
 * http://www.loopindex.com/lite/docs/
 *
 * @see lite_filter_process_format()
 */
function lite_disable_tracking($element) {

  if (isset($element['#lite_node_values'])) {
    // Recover our settings and pass it to the DrupalSettings js array for use
    // in our plugin.
    $node = $element['#lite_node_values'];
    $is_new = $node['new'];
    $element['#attached']['drupalSettings']['lite']['node'] = $node;
    $config = \Drupal::config('lite.settings');
    $debug = $config->get('debug');
    $element['#attached']['drupalSettings']['lite']['debug'] = $debug;
  }
  else {
    return $element;
  }

  // Retrieve the available formats for the current text_format.
  $format_options = $element['format']['format']['#options'];

  // Loop through each of the available formats, adding a JS setting which
  // disabled tracking depeding format settings.
  foreach ($format_options as $format => $label) {
    if (isset($element['#attached']['drupalSettings']['editor']['formats'][$format]['editorSettings'])) {
      // Just simplify the array.
      $editor_settings = &$element['#attached']['drupalSettings']['editor']['formats'][$format]['editorSettings'];
      // If drupal lite is not enable we can stop here.
      if (!isset($editor_settings['lite'])) {
        continue;
      }

      // Check if the workflow is overriden from the text format settings.
      $options = $editor_settings['lite']['options'];
      if (!count($options)) {
        continue;
      }
      if (isset($options['moderation'])) {
        if ($options['moderation'] == 0 || $node['moderated'] == FALSE || $options['moderation_options'][$node['workflow']]['enable'] == 0) {
          // We are not dealing with a moderated or text format settings is
          // disable. By default tracking is always enable, we check if we need to
          // disable it when not enable by default or disabled on new entities.
          if ($options['auto_start'] == 0 || ($is_new && $options['disable_new'] == 1)) {
            $editor_settings['lite']['isTracking'] = FALSE;
          }
          continue;
        }
      }

      // It's a new node without state, so check new entity setting.
      if ($is_new) {
        if ($options['disable_new'] == 1) {
          $editor_settings['lite']['isTracking'] = FALSE;
        }
      }
      // For an exisitng node, apply the setting for this Workflow state.
      else {
        $options = $options['moderation_options'][$node['workflow']][$node['state']];
        if ($options['auto_start'] == 0) {
          $editor_settings['lite']['isTracking'] = FALSE;
        }
      }
    }
  }

  return $element;
}

/**
 * Permission callback for Lite's lite.permissions.yml.
 *
 * @see lite.permissions.yml
 */
function lite_permissions() {
  $permissions = [];

  // We can stop here if permission by formats is not enable.
  $config = \Drupal::config('lite.settings');
  $extra_permissions = $config->get('extra_permissions');

  if (!empty($extra_permissions) && function_exists('lite_' . $extra_permissions)) {
    $function_name = 'lite_' . $extra_permissions;
    $base_permissions = [
      'lite toggle' => [
        'base_title' => '%target: May enable or disable tracking',
      ],
      'lite resolve' => [
        'base_title' => '%target: May resolve changes',
      ],
    ];
    return $function_name($base_permissions);
  }

  return $permissions;
}

/**
 * Create permissions for each format with Lite enable.
 */
function lite_permissions_by_formats($base_permissions) {
  $permissions = [];
  $formats = [];

  // Build a list of formats with lite enable.
  $filter_formats = filter_formats();
  foreach ($filter_formats as $filter_format) {
    $filters = $filter_format->get('filters');
    if (isset($filters['lite'])) {
      $formats[$filter_format->id()] = $filter_format->label();
    }
  }

  // Create permissions for each text format.
  foreach ($formats as $id => $format_name) {
    foreach ($base_permissions as $base_permission => $tracking_info) {
      $permissions[$base_permission . ' ' . $id] = [
        'title' => t($tracking_info['base_title'], ['%target' => $format_name]),
        'description' => t('Ensure user can use this <em>format</em> to be able to use this permission.'),
      ];
    }
  }

  return $permissions;
}

/**
 * Permission callback for Lite's lite_content_moderation.permissions.yml.
 *
 * @see lite_content_moderation.permissions.yml
 */
function lite_permissions_by_states($base_permissions) {
  $permissions = $workflows = [];

  // On 8.3.x moderation apply only on nodes.
  $bundles = \Drupal::service('entity_type.bundle.info')->getBundleInfo('node');
  foreach ($bundles as $info) {
    if (isset($info['workflow'])) {
      $workflows[] = $info['workflow'];
    }
  }

  foreach ($workflows as $workflow_id) {
    // We are not sure workflow module is enable, so we use statements to use
    // Workflow class.
    // @codingStandardsIgnoreStart
    if ($workflow = \Drupal\workflows\Entity\Workflow::load($workflow_id)) {
      // @codingStandardsIgnoreEnd
      $states = $workflow->getStates();
      foreach ($base_permissions as $base_permission => $tracking_info) {
        foreach ($states as $state) {
          $permissions[$base_permission . ' ' . $workflow_id . ' ' . $state->id()] = [
            'title' => t($tracking_info['base_title'], ['%target' => $workflow->label() . ', ' . $state->label()]),
            'description' => t('Ensure user can use this <em>state</em> to be able to use this permission.'),
          ];
        }
      }
    }
  }

  return $permissions;
}
